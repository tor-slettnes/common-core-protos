// -*- Protocol-Buffers -*-
//==============================================================================
/// @file vfs.proto
/// @brief Virtual Filesystem ProtoBuf data types
/// @author Tor Slettnes <tor@slett.net>
//==============================================================================

syntax = "proto3";

package cc.platform.vfs.protobuf;

import "google/protobuf/timestamp.proto";
import "cc/protobuf/signal/signal.proto";
import "cc/protobuf/variant/variant.proto";


enum PathType
{
    // Synchronized to C++ STL 'std::filesystem::file_type'
    TYPE_NONE      = 0;         // Not applicable, or unknown
    TYPE_FILE      = 1;         // Regular file
    TYPE_DIRECTORY = 2;         // Regular directory
    TYPE_SYMLINK   = 3;         // Symbolic link
    TYPE_CHARDEV   = 4;         // Character special device
    TYPE_BLOCKDEV  = 5;         // Block special device
    TYPE_PIPE      = 6;         // Named pipe
    TYPE_SOCKET    = 7;         // Named (UNIX domain) socket
}


message ContextSpec
{
    // Name for this context.
    string name = 1;

    // Root of context within native filesystem
    string root = 2;

    // Writable access granted
    // Individual files/folers may have further restrictions.
    bool writable = 3;

    // Whether the context represents a removable volume (e.g. USB drive);
    // Only used in replies from server.
    bool removable = 4;

    // Human readable name (e.g volume label for a removable drive)
    string title = 5;

}

message ContextMap
{
    map<string, ContextSpec> map = 1;
}


message Path
{
    // Virtual Filesystem Context, e.g., "usb0", "logs", ...
    string context = 1;

    // Path relative to context
    string relpath = 2;
}

message PathRequest
{
    // Virtual path comprising a filesystem context and a relative path.
    Path path = 2;

    // Source path(s) for `copy()` / `move()`, as well as optional additional
    // paths for `remove()`.
    repeated Path sources = 3;

    // Enables the following behaviors, rather than failing:
    //   - Recursively copy/move/remove a folder and its children
    //   - Replaces an existing target regardless of type
    //   - Copies metadata from source, even if replacing existing target
    //   - Creates missing parent folder(s) leading up to `target`.
    bool force = 4;

    // Whether to follow symbolic links on source or target.
    // Be vewwy vewwy cautious when used together with `force`.
    // Note that links are never followed outside the context.
    bool dereference = 5;

    // Merge rather than replace an existing target folder.
    // Effective only if `path` and all `sources` are folders.
    bool merge = 6;

    // Update only; only copy if target does not exist or is older than source.
    bool update = 7;

    // Include custom attributes in request
    bool with_attributes = 8;

    // Include hidden files in directory list
    bool include_hidden = 9;

    // Indicates that `target` is not the final target path, but a
    // parent folder into which the source path(s) will be copied/moved.
    // copy()/move() require this option if there is more than one source.
    bool inside_target = 10;
}

message LocateRequest
{
    // Where to start the search
    Path root = 1;

    // Zero or more glob-style filename masks, e.g., `*.txt`.
    repeated string filename_masks = 2;

    // Zero or more tag/value pairs to match.
    // Tags may be repeated for cumulative value matches.
    cc.protobuf.variant.TaggedValueList attribute_filters = 5;

    // Include custom attributes in request
    bool with_attributes = 8;

    // Include hidden files in directory list
    bool include_hidden = 9;

    // Ignore case in filename
    bool ignore_case = 10;
}

message FileInfo
{
    string name = 1;         // Base name, without leading directory
    PathType type = 2;       // DIRECTORY, FILE, etc.
    uint64 size = 3;         // Size in bytes
    string link = 4;         // Target for symbolic links
    uint32 mode = 5;         // UNIX mode mask
    bool readable = 6;       // Readable file/listable directory
    bool writable = 7;       // Writable file/modifiable directory
    uint32 uid   = 8;        // Owner numeric ID
    uint32 gid   = 9;        // Group numeric ID
    string ownername = 10;   // Owner name
    string groupname = 11;   // Group name (`group` is a reserved ProtoBuf word)
    google.protobuf.Timestamp access_time = 12;  // Last access
    google.protobuf.Timestamp modify_time = 13;  // Last modification
    google.protobuf.Timestamp create_time = 14;  // Creation
    cc.protobuf.variant.KeyValueMap attributes = 15; // Custom file attributes
    // TBD: Access Control Lists, SELinux contexts
}

message Directory
{
    map<string, FileInfo> map = 1;
}

message AttributeRequest
{
    Path path = 1;
    cc.protobuf.variant.KeyValueMap attributes = 2;
}

message VolumeInfo
{
    uint64 capacity   = 1;      // Total size, in bytes
    uint64 free       = 2;      // Free size, in bytes
    uint64 available  = 3;      // Available size, in bytes
}

message FileChunk
{
    Path path = 1;
    bytes data = 2;
}

//==============================================================================
// A `Signal` message is a multiplexer for various event types from the server,
// streamed back to the client in response to a `Watch()` invocation, above.
// The event stream continues indefinitely until the client cancels the call or
// disconnects.
//
// To listen for only specific event types, apply a corresponding signal filter
// as input parameter to the `Watch()` call. The filter should contain a list of
// field indices to include or exclude, based on their field numbers within the
// `oneof` block below. The filter also contains a `polarity` field to indicate
// whether the listed fields are to be included (1) or excluded (0).  As such,
// an empty filter means that all events will be streamed back to the client.


message Signal
{
    // Mapping type, one of: MAP_NONE, MAP_ADDITION, MAP_REMOVAL, MAP_UPDATE.
    // Indicates whether this instance is added, updated, or removed.
    cc.protobuf.signal.MappingAction mapping_action = 1;

    // Mapping key for the item that was added/removed/updated.
    string mapping_key = 2;

    oneof signal {
        // Filesystem context event.
        //  * `mapping_action` indicates whether the context was added,
        //    removed, or updated.
        //  * `mapping_key` is the name of the context
        ContextSpec context = 8;

        // Filesystem context is in use.
        //  * `mapping_action` is MAP_ADDITION or MAP_REMOVAL, depending
        //    on whether the indicated context was opened or closed.
        //  * `mapping_key` is the name of the context
        ContextSpec context_in_use = 9;
    };
}
